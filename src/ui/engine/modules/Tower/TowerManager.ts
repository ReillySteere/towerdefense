import { Tower } from './Tower';
import { GameGrid } from '../../core/GameGrid';
import {
  PathPlanningService,
  type IGridPosition,
} from '../../services/PathPlanningService';
import { Projectile } from './Projectile';
import { IWaypoint } from '../../entities/waypoint/IWaypoint';
import { GameState } from 'ui/engine/modules/Game/GameState';
interface TowerManagerProps {
  gameGrid: GameGrid;
  pathPlanningService: PathPlanningService;
  scene: Phaser.Scene;
}
class TowerManager {
  #gameGrid: GameGrid;
  #pathPlanningService: PathPlanningService;
  #scene: Phaser.Scene;
  #state: GameState;

  #towers: Tower[] = [];

  constructor({ gameGrid, pathPlanningService, scene }: TowerManagerProps) {
    this.#gameGrid = gameGrid;
    this.#pathPlanningService = pathPlanningService;
    this.#scene = scene;
    this.#state = GameState.getInstance();
  }

  /**
   * Check if a tower already exists at (x, y).
   */
  hasTowerAt(x: number, y: number): boolean {
    return this.#towers.some((tower) => tower.x === x && tower.y === y);
  }

  /**
   * Return a list of obstacles from both towers and the grid.
   */
  getObstacleSet(): Set<string> {
    const obstacles = new Set<string>();
    // Add tower positions as obstacles.
    this.#towers.forEach((tower) => {
      obstacles.add(`${tower.x},${tower.y}`);
    });
    // Also include any obstacles already set in the grid.
    this.#gameGrid.getObstacles().forEach((key) => obstacles.add(key));
    return obstacles;
  }

  /**
   * Validate whether a candidate tower can be placed:
   * - The target cell must not be already occupied.
   * - The candidate should not block any necessary path between waypoints.
   */
  public canPlaceTower(baseRoute: IWaypoint[], candidateTower: Tower): boolean {
    // Reject if the grid cell is already occupied, either by a tower or a grid obstacle.
    if (
      this.#gameGrid.isCellOccupied(candidateTower.x, candidateTower.y) ||
      this.hasTowerAt(candidateTower.x, candidateTower.y)
    ) {
      return false;
    }

    // Create a candidate obstacle set including the new tower.
    const candidateObstacles = this.getObstacleSet();
    candidateObstacles.add(`${candidateTower.x},${candidateTower.y}`);

    if (baseRoute.length < 2) {
      return false;
    }

    // Validate the route between each pair of consecutive waypoints.
    for (let i = 0; i < baseRoute.length - 1; i++) {
      const startGrid: IGridPosition = {
        x: Math.min(baseRoute[i].x, this.#gameGrid.width - 1),
        y: Math.min(baseRoute[i].y, this.#gameGrid.height - 1),
      };
      const endGrid: IGridPosition = {
        x: Math.min(baseRoute[i + 1].x, this.#gameGrid.width - 1),
        y: Math.min(baseRoute[i + 1].y, this.#gameGrid.height - 1),
      };

      const newPath = this.#pathPlanningService.computePath(
        startGrid,
        endGrid,
        candidateObstacles,
      );

      if (!newPath || newPath.length === 0) {
        console.warn(
          `[TowerManager] Tower candidate at (${candidateTower.x}, ${candidateTower.y}) blocks the path between (${startGrid.x}, ${startGrid.y}) and (${endGrid.x}, ${endGrid.y}).`,
        );
        return false;
      }
    }
    return true;
  }

  /**
   * Place the tower:
   * - Validate placement.
   * - Mark the grid cell as occupied.
   * - Publish an event to trigger re-routing of enemies.
   */
  addTower({
    baseRoute,
    gridX,
    gridY,
  }: {
    baseRoute: IWaypoint[];
    gridX: number;
    gridY: number;
  }): boolean {
    const newTower = new Tower(gridX, gridY);

    if (this.#state.money < newTower.cost) {
      this.#scene.events.emit('towerPlacementFailed', {
        reason: 'insufficientFunds',
      });
      this.#scene.events.emit('debugError', {
        message: 'Insufficient funds for tower placement.',
        source: 'TowerManager',
      });
      return false;
    }
    if (!this.canPlaceTower(baseRoute, newTower)) {
      this.#scene.events.emit('towerPlacementFailed', {
        reason: 'invalidPlacement',
      });
      this.#scene.events.emit('debugError', {
        message:
          'Invalid tower placement: either already placed or blocking access.',
        source: 'TowerManager',
      });
      return false;
    }

    this.#state.spendMoney(newTower.cost);
    this.#scene.events.emit('moneyUpdate', this.#state.money);

    this.#gameGrid.setCellOccupancy(newTower.x, newTower.y, true);
    this.#towers.push(newTower);

    const obstacles = this.getObstacleSet();
    this.#scene.events.emit('obstaclesUpdated', { obstacles });

    return true;
  }

  /**
   * Iterates over all towers and updates them with the given enemies.
   * Returns an array of projectiles generated by towers.
   *
   * @param currentTime - The current time in milliseconds.
   * @param gridSize - The size (in pixels) of a grid cell.
   * @param enemies - An array of enemies in the game.
   */
  public updateTowers(
    currentTime: number,
    gridSize: number,
    enemies: any[],
  ): Projectile[] {
    const projectiles: Projectile[] = [];
    this.#towers.forEach((tower) => {
      enemies.forEach((enemy) => {
        const projectile = tower.update(enemy, currentTime, gridSize);
        if (projectile) {
          projectiles.push(projectile);
        }
      });
    });
    return projectiles;
  }
  /**
   * Render towers.
   */
  draw(graphics: Phaser.GameObjects.Graphics): void {
    this.#towers.forEach((tower) => {
      graphics.fillStyle(0x0000ff, 1);
      const { pixelX, pixelY } = this.#gameGrid.gridToPixel(tower.x, tower.y);
      graphics.fillRect(
        pixelX - tower.size / 2,
        pixelY - tower.size / 2,
        tower.size,
        tower.size,
      );
    });
  }

  clearAll() {
    this.#towers = [];
  }
}

export default TowerManager;
